[ { "title": "咋就困了呢", "url": "/posts/daily-g2/", "categories": "每日一G", "tags": "", "date": "2022-05-16 00:00:00 +0800", "snippet": "流水账原本写了一堆乱七八糟的文字，回看起来又觉着不知所云。感觉自己的表达水平确实挺糟糕，不适合些什么严谨的内容。今晚做了个 OH Cards 的咨询，咨询结束就想记录点什么。我和 Jane 说：“我看你朋友圈，感恩二字让我感到不舒适。”她告诉我：“为什么不舒适，自己去品品。 ”品到这里，我突然感觉挺搞笑的。自己像是个刻薄的小学生，要把同学随手打的一句话，拿出来逐字点评。工科思维害人不浅我没有深入了解过心理学，如今我还是用玄学的视角看它。从吐槽的角度来说，我感觉这玩意儿更像一种迷信？说好听点叫信仰。我疑心太重，似乎很难成为什么信徒。所有心理向的咨询，好像都是这个样子。去咨询的人，都怀疑自己是不是不正常。而所谓正常，是高基数人群定义的。咨询师会根据你的输入，给你一个正向的思维方式，并建议你用这种方式思考。这套方法论在你的大脑上成功运行前，无法证实是否行之有效。如果无效，可能是你的操作方式不对，大脑配置太低，或者系统不兼容？就算输出了成功的结果，真的能把底层BUG修复了吗？从这个视角看，我能够理解到鹏鹏对脑科学高度发展的期待了。我也想抛开自己的脑袋瓜子，看看里面写的都是什么逻辑。比起心理向咨询来说，切开大脑确实是更令人信服的方案。混沌今天早上，我和我爹说：“我这几天写代码，有个感受。感觉这个世界上的所有东西都非常混乱。”我爹又一脸吃惊：“什么混乱？” 估计我爹以为我出现了什么幻觉。因为我表达能力差，也没讲明白个所以然。 你会不会偶尔感觉，周围的所有东西都非常复杂。而复杂源于不规律，人类好像天生就喜欢规律的东西。就比如我写的垃圾代码，自己看起来都感觉不适。这种混沌，好像藏在所有事物的夹缝里。远看，一片宁静祥和。 细品，什么狗屎玩意？有时候你会连连叫叹：“妙啊，妙啊。”摸不着头脑的时候，又会大骂：“傻逼玩意儿。”是吧，就连我们对事物的看法，都如此的混沌。突然犯困了，不写了。" }, { "title": "五月十六日风雨大作", "url": "/posts/daily-g1/", "categories": "每日一G", "tags": "", "date": "2022-05-16 00:00:00 +0800", "snippet": "前言每日一G前阵子在知乎上看 Anlin 写的《外卖日寄》，感觉蛮有意思，创作欲被激发了吧。因为这个博客系统需要自己整文件命名，为了统一，就给这个系列命名为“每日一G”，也容易写成”daily-g”。可能未来会发展成：三天一”g”，五天一”G”。为什么用中文因为英文太差了，昨天晚上又用脑过度，翻译模块宕机了。就算不宕机，估计也写不出这么复杂的外国话。编程流水账刷了一夜的 Django ORM DOC，起因是很无聊的一个需求：整一个 M2MRelateNestedSerializer： 这个 Serializer 能够从一端开始，构建三层的嵌套关系。 能通过第二层（也就是 through 指向的 Model）的 Field 来筛选出第三层的 Model。 详情见 StackOverflow。直接看没啥问题，挺正常的一个需求，但是问题出在我对 Django ORM 的熟练度上。之前也碰到过类似的问题，一个关于 QuerySet 关联对象 filter 不生效的问题，拉着鹏哥看源码 + 玄学调试法。整了好几个钟都没解决，第二天碰巧在 StackOverflow 上看到一个回答。点进去，嘿，您猜怎么着，上 Prefetch！今天又遇到 Django ORM 领域的内容了，折腾了好几个小时，没看懂。我就想，那要不乖乖把官方文档啃一遍吧，看完了应该就会了吧。什么 Subquery, OuterRef，整的一头雾水，改天再细细琢磨。突然感觉追求 “最佳实现” 的编程风格是真的低效。其实也算不上 “最佳实现”，只是懒得自己写逻辑复杂的代码。“多写多错，少些少错。” —— 954今日流水账应该说是昨天，离昨天已经过去了九个小时。为了把我这昼夜颠倒的生物钟掰正，预约了个今晚的咨询。原因是最近我爹总在唠叨：“我看，最主要的是把睡眠弄规律了，把身体养好了比什么都重要。”其实我独居的时候，睡眠还挺规律的，三四睡觉，十一二点起床，我觉得挺健康。偶尔因为外界的因素，就会因为这个生物钟自责。然后就开始连续几天的倒时差。倒时差是真的难受，要把二十四小时制延长成三十六小时制，而且又时常不生效。自从我爱上深夜，好像经常间接性倒时差，这感觉像是在偷情。那天和姨丈聊天，跟他分享了自己的一些想法和看法。他听完这些，说，有些想法他都不知道怎么接话了，只能用“异类”评价我，褒贬不一。我们之前接触的不多，所以他对于我这些怪想法的由来，感到好奇。我说可能是受的打击多了，寻常路走不通，那就棋出险招。我爹在一旁一脸吃惊，问了句：“什么打击？”那天晚上我和酒后的老爹又聊到相似的话题。我有时候挺羡慕他，或者说羡慕中年人。感觉这个时代背景下，中年人比年轻人有活力太多了。他们接触互联网的时间没那么长，看到的风言风语没那么多。骨子里还淌着那个年代独有的热血。我不敢年龄黑啊，至少我自己，心态上不如他们年轻。那天他又对我这种消极的心态提出批判时，我捎带着逻辑给他绕了一圈。拿“原始人遇到猛兽，战或逃？”举了个例子。我是那种尽量逃的人，因为我的生活经验告诉我，逃往往更可靠。而他这种习惯了战的人，就看不惯逃。所以我就逃了，不聊了。" }, { "title": "Use `WritableStringRelatedField` in `Django REST Framework`", "url": "/posts/writable-string-related-field/", "categories": "Django REST Framework", "tags": "Django, Django-REST-Framework, DRF", "date": "2022-05-15 00:00:00 +0800", "snippet": "Cause:There has a question onStackOverflow: How can I show the StringRelatedField instead of the Primary Key while still being able to write-to that field using Django Rest Framework?I also encountered this problem during development. So I started trying to solve this problem myself.I want to see the success solution directly. Jump to Success SolutionError direction - use @property:First, I tried to add a @property function in the model, and use SlugRelatedField to realize.It always useful in SlugRelatedField(read_only=True,).# Models:class RosterInstance(models.Model): # ... @property def representation(self): return self.date.strftime(&quot;%d %b, %Y&quot;) @representation.setter def representation(self, value): self.date = value def __str__(self): return self.representation# Serializers:class RosterInstanceSerializer(serializers.ModelSerializer): deckhand_watchkeeper = serializers.SlugRelatedField( queryset=CrewMember.objects.all(), slug_field=&#39;representation&#39;, label=&#39;Deckhand Watchkeeper&#39;, ) night_watchkeeper = serializers.SlugRelatedField( queryset=CrewMember.objects.all(), slug_field=&#39;representation&#39;, label=&#39;Night Watchkeeper&#39;, ) class Meta: model = RosterInstance fields = &quot;__all__&quot;But I got an error in:to_internal_value /rest_framework/relations.py - line 462# /rest_framework/relations.pydef to_internal_value(self, data): queryset = self.get_queryset() try: return queryset.get(**{self.slug_field: data}) except ObjectDoesNotExist: self.fail(&#39;does_not_exist&#39;, slug_name=self.slug_field, value=smart_str(data)) except (TypeError, ValueError): self.fail(&#39;invalid&#39;)Because there use querset.get(**{self.slug_field: data}) to get the object. It needs a real Field,but self.slug_field is a custom property.The @representation.setter is foolish and superfluous, it’s impossible be called by the function stack at all.We got a conclusion:SlugRelatedField is exactly a writeable field, but it doesn’t support read and write a not Field property at sametime.What does SlugRelatedField do?So, I think: Why didn’t rewrite SlugsRelatedField?Let’s seethe SlugsRelatedField rest_framework/relations.py - line 444: It extends from RelatedField and rewrite the to_internal_value and to_representation function. to_internal_value: It try to get a queryset to build relation. to_representation: It return a value what you want to display in views.# /rest_framework/relations.pyclass SlugRelatedField(RelatedField): &quot;&quot;&quot; A read-write field that represents the target of the relationship by a unique &#39;slug&#39; attribute. &quot;&quot;&quot; default_error_messages = { &#39;does_not_exist&#39;: _(&#39;Object with {slug_name}={value} does not exist.&#39;), &#39;invalid&#39;: _(&#39;Invalid value.&#39;), } def __init__(self, slug_field=None, **kwargs): assert slug_field is not None, &#39;The `slug_field` argument is required.&#39; self.slug_field = slug_field super().__init__(**kwargs) def to_internal_value(self, data): queryset = self.get_queryset() try: return queryset.get(**{self.slug_field: data}) except ObjectDoesNotExist: self.fail(&#39;does_not_exist&#39;, slug_name=self.slug_field, value=smart_str(data)) except (TypeError, ValueError): self.fail(&#39;invalid&#39;) def to_representation(self, obj): return getattr(obj, self.slug_field)Create a custom FieldWe can create a custom field to replace the SlugsRelatedField, I named it WritableStringRelatedField.Because it’s sames like a StringRelatedField, although it extends from SlugRelatedField.Maybe you want name it MagicSlugsRelatedField, whatever.Let’s see code: It extends from WritableStringRelatedField and rewrite the __init__, to_representation, slug_representation, get_choices function. __init__: I defined a display_field to set what property you want to display, if None, it will use __str__. If you don’t set the label, it will auto get verbose_name_raw by queryset. So you can just set the queryset. to_representation: It combines StringRelatedField.to_representation and SlugRelatedField.to_representation, asjudged by display_field. slug_representation: Sames as SlugRelatedField.to_representation. get_choices: Same as SlugRelatedField.get_choices, only the self.slug_representation(item) of the returnchanged. In source is self.to_representation(item)rest_framework/relations.py - line 204# fields.pyfrom collections import OrderedDictfrom rest_framework import serializersclass WritableStringRelatedField(serializers.SlugRelatedField): def __init__(self, slug_field=&quot;pk&quot;, display_field=None, *args, **kwargs): self.display_field = display_field # Set what attribute to be represented. # If `None`, use `Model.__str__()` . if not kwargs.get(&quot;label&quot;, None): kwargs[&quot;label&quot;] = kwargs[&quot;queryset&quot;].model._meta.verbose_name_raw super(WritableStringRelatedField, self).__init__(slug_field, **kwargs) def to_representation(self, obj): # This function controls how to representation field. if self.display_field: return getattr(obj, self.display_field) return str(obj) def slug_representation(self, obj): # It will be called by `get_choices()`. return getattr(obj, self.slug_field) def get_choices(self, cutoff=None): queryset = self.get_queryset() if queryset is None: # Ensure that field.choices returns something sensible # even when accessed with a read-only field. return {} if cutoff is not None: queryset = queryset[:cutoff] return OrderedDict([ ( self.slug_representation(item), # Only this line has been overridden, # the others are the same as `super().get_choices()`. self.display_value(item) ) for item in queryset ])You can use it easily.# Serializers.pyclass RosterInstanceSerializer(serializers.ModelSerializer): deckhand_watchkeeper = WritableStringRelatedField( queryset=CrewMember.objects.all(), slug_field=&#39;id&#39;, label=&#39;Deckhand Watchkeeper&#39;, ) # Or only set the queryset. night_watchkeeper = WritableStringRelatedField( queryset=CrewMember.objects.all(), ) class Meta: model = RosterInstance fields = &quot;__all__&quot;" } ]
